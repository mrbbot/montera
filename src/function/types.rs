use crate::class::{ConstantPool, FieldId, MethodDescriptor, MethodId};
use crate::function::locals::LocalInterpretation;
use classfile_parser::code_attribute::Instruction as JVMInstruction;
use classfile_parser::method_info::MethodAccessFlags;
use std::sync::{Arc, Mutex};
use wasm_encoder::Instruction as WASMInstruction;

/// Parsed function in a Java `.class` file containing JVM bytecode.
/// Input to [`crate::function::CompileFunctionJob`].
#[derive(Debug)]
pub struct Function {
    /// Unique universal identifier for this method in the program.
    pub id: MethodId,
    /// Method flags, e.g. `public`, `static`, `native`, `abstract`, ...
    pub flags: MethodAccessFlags,
    /// Method parameter and return types.
    pub descriptor: Arc<MethodDescriptor>,
    /// Reference to constant pool of containing class.
    pub const_pool: Arc<ConstantPool>,
    /// JVM bytecode for this function. Only included if this function isn't `native` or `abstract`.
    /// `Mutex` provides interior mutability, we want to take ownership and move this code when
    /// structuring.
    pub code: Mutex<Option<Vec<(usize, JVMInstruction)>>>,
}

/// Intermediate instructions generated by function visiting phase for module rendering phase.
///
/// Includes all simple WebAssembly instructions with additional pseudo-instructions requiring
/// virtual method tables or built-in functions. These are lowered to simple instructions when
/// rendering the final WebAssembly module.
#[derive(Debug)]
pub enum Instruction<'a> {
    /// Simple WebAssembly instruction.
    I(WASMInstruction<'a>),

    /// Duplicates the value at the top of the stack:
    /// `[value: t] -> [value: t, value: t]`
    Dup,

    /// Creates a new instance of the specified class on the heap returning a reference:
    /// `[] -> [ptr: i32]`
    New(Arc<String>),
    /// Checks if the reference is an `instanceof` the specified class:
    /// `[ptr: i32] -> [is: i32]`
    InstanceOf(Arc<String>),

    /// Gets the value of the specified field of the object reference on the top of the stack:
    /// `[this: i32] -> [value: t]`
    GetField(FieldId),
    /// Puts the value into the specified field of the object reference on the top of the stack:
    /// `[this: i32, value: t] -> []`
    PutField(FieldId),

    /// Calls the specified static method (no dynamic dispatch), popping the required number of
    /// parameters off the stack and pushing back the result:
    /// `[...] -> [return: t]`
    CallStatic(MethodId),
    /// Calls the specified instance method (using dynamic dispatch), popping the required number of
    /// parameters off the stack (including an implicit `this` reference) and pushing back the
    /// result:
    /// `[this: i32, ...] -> [return: t]`
    CallVirtual(MethodId),

    /// Pops two `long` values `a` and `b` off the top of the stack, returning -1 if `a < b`, 0 if
    /// `a = b` and 1 if `a > b`:
    /// `[a: i64, b: i64] -> [ord: i32]`
    LongCmp,
    /// Pops two `float` values `a` and `b` off the top of the stack, returning -1 if `a < b`, 0 if
    /// `a = b` and 1 if `a > b`. If either `a` or `b` is NaN, the result is determined by the
    /// specified [`NaNBehaviour`]:
    /// `[a: f32, b: f32] -> [ord: i32]`
    FloatCmp(NaNBehaviour),
    /// Pops two `double` values `a` and `b` off the top of the stack, returning -1 if `a < b`, 0 if
    /// `a = b` and 1 if `a > b`. If either `a` or `b` is NaN, the result is determined by the
    /// specified [`NaNBehaviour`]:
    /// `[a: f64, b: f64] -> [ord: i32]`
    DoubleCmp(NaNBehaviour),
}

/// Controls what `Instruction::FloatCmp` or `Instruction::DoubleCmp` should return if either of
/// their arguments are NaN.
#[derive(Debug, Copy, Clone)]
pub enum NaNBehaviour {
    /// If either `a` or `b` is NaN, return 1 (`a > b`)
    Greater,
    /// If either `a` or `b` is NaN, return -1 (`a < b`)
    Lesser,
}

impl NaNBehaviour {
    /// Returns the value for the `nan_greater` parameter accepted by functions constructed by
    /// [`crate::output::builtin::compare::construct_compare`].
    pub fn as_nan_greater_int(&self) -> i32 {
        match self {
            NaNBehaviour::Greater => 1,
            NaNBehaviour::Lesser => 0,
        }
    }
}

/// Compiled function containing WebAssembly with pseudo-[`Instruction`]s.
/// Output of [`crate::function::CompileFunctionJob`].
#[derive(Debug)]
pub struct CompiledFunction {
    /// Unique universal identifier for this method in the program.
    pub id: MethodId,
    /// Method flags, e.g. `public`, `static`, `native`, `abstract`, ...
    pub flags: MethodAccessFlags,
    /// Method parameter and return types.
    pub descriptor: Arc<MethodDescriptor>,
    // TODO (someday): maybe split this out into separate struct, then only one Option<...>,
    //  then assert is_none() in visit_import() to remove expect()s in visit_function()
    /// Local interpretation mapping JVM stack index and WebAssembly type pairs to their WebAssembly
    /// local indices. See [`LocalInterpretation`] for more details on why this is needed. Only set
    /// if this function has code (i.e. it doesn't have `native` or `abstract` flags).
    pub locals: Option<Arc<LocalInterpretation>>,
    /// Output of visiting phase. Only set if this function has code (i.e. it doesn't have `native`
    /// or `abstract` flags).
    pub code: Option<Vec<Instruction<'static>>>,
}

impl CompiledFunction {
    /// Returns `true` if and only if this function should be a WebAssembly import (it has it's
    /// implementation defined by the host language). This is the case for `native` methods.
    pub fn is_import(&self) -> bool {
        self.flags.contains(MethodAccessFlags::NATIVE)
    }

    /// Returns `true` if and only if this is an `abstract` function, without an implementation.
    pub fn is_abstract(&self) -> bool {
        self.flags.contains(MethodAccessFlags::ABSTRACT)
    }

    /// Returns `true` if and only if this is a `static` function, without an implicit `this`
    /// parameter.
    pub fn is_static(&self) -> bool {
        self.flags.contains(MethodAccessFlags::STATIC)
    }

    /// Returns `true` if and only if this function should be a WebAssembly export (callable from
    /// the host language). This is the case for `public static` methods.
    pub fn is_export(&self) -> bool {
        self.flags
            .contains(MethodAccessFlags::PUBLIC | MethodAccessFlags::STATIC)
    }
}
